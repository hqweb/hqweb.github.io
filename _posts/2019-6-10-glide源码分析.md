---

layout:     post   				    
title:      Glide源码分析			 
subtitle:   Glide源码分析
date:       2019-06-10 				
author:     hq 						
header-img: img/post-bg-2015.jpg 	
catalog: true 						
tags:								
    - 源码
---

# Glide源码分析

**Glide是一款图片非常灵活的加载框架，自带内存，磁盘缓存。可自定义各种模块，比如网络框架，缓存模块，加载图片。**

## 基本用法

[Glide官网](https://muyangmin.github.io/glide-docs-cn/)

版本4.9.0

```groovy
 implementation 'com.github.bumptech.glide:glide:4.9.0'
```

下面例子可以去我的GitHub下载，强烈建立去下载，跟着源码一起走

```java
 Glide.with(this)
      .load("https://bing.ioliu.cn/photo/JaguarPantanal_ZH-CN6062516404?force=home_1")
      .into(imageView);
```

## 源码分析

Glide最基本的用法分三步：先with()，在load()，最后into()。我们就来一步步分析。

### with()

with这个方法有很多重载，其实都是返回一个`RequestManager`对象。

```java
public class Glide implements ComponentCallbacks2 {
    
    ......
        
    public static RequestManager with(@NonNull Context context) {
        return getRetriever(context).get(context);
      }

      public static RequestManager with(@NonNull Activity activity) {
        return getRetriever(activity).get(activity);
      }


      public static RequestManager with(@NonNull FragmentActivity activity) {
        return getRetriever(activity).get(activity);
      }


      public static RequestManager with(@NonNull Fragment fragment) {
        return getRetriever(fragment.getActivity()).get(fragment);
      }


      public static RequestManager with(@NonNull android.app.Fragment fragment) {
        return getRetriever(fragment.getActivity()).get(fragment);
      }


      public static RequestManager with(@NonNull View view) {
        return getRetriever(view.getContext()).get(view);
      }
}
```

可以看到，with方法分为两步

- `FragmentActivity`，`Fragment`,`View`的`Context`为参数，调用静态方法`getRetriever`获取`RequestManagerRetriever`对象，这个静态方法就是一个单例的实现。
- 通过`RequestManagerRetriever`的众多重载方法`get`获取`RequestManager`对象.重点谈谈这个`get`方法

别看下面这么复杂，其实最终都是添加一个隐藏的`Fragment`

```java
public class RequestManagerRetriever implements Handler.Callback {
    
    。。。。。。
        
        //全局Aplication获取RequestManager
      private RequestManager getApplicationManager(@NonNull Context context) {
        if (applicationManager == null) {
          synchronized (this) {
            if (applicationManager == null) {
              Glide glide = Glide.get(context.getApplicationContext());
              applicationManager =
                  factory.build(
                      glide,
                      new ApplicationLifecycle(),
                      new EmptyRequestManagerTreeNode(),
                      context.getApplicationContext());
            }
          }
        }

        return applicationManager;
      }

 		//获取context的RequestManager对象
      public RequestManager get(@NonNull Context context) {
        if (context == null) {
          throw new IllegalArgumentException("You cannot start a load on a null");
        } else if (Util.isOnMainThread() && !(context instanceof Application)) {
            //通过不同的重载方法get获取RequestManager对象
          if (context instanceof FragmentActivity) {
            return get((FragmentActivity) context);
          } else if (context instanceof Activity) {
            return get((Activity) context);
          } else if (context instanceof ContextWrapper) {
            return get(((ContextWrapper) context).getBaseContext());
          }
        }
		//上面条件不通过，按全局context处理
        return getApplicationManager(context);
      }

    
      public RequestManager get(@NonNull FragmentActivity activity) {
        if (Util.isOnBackgroundThread()) {
            //非主线程按全局context处理
          return get(activity.getApplicationContext());
        } else {
          assertNotDestroyed(activity);
            //重点，获取ftagment的管理者FragmentManager对象
          FragmentManager fm = activity.getSupportFragmentManager();
          return supportFragmentGet(
              activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
        }
      }

      
      public RequestManager get(@NonNull Fragment fragment) {
        if (Util.isOnBackgroundThread()) {
            //非主线程按全局context处理
          return get(fragment.getActivity().getApplicationContext());
        } else {
            //重点，获取ftagment的管理者FragmentManager对象
          FragmentManager fm = fragment.getChildFragmentManager();
          return supportFragmentGet(fragment.getActivity(), fm, fragment, fragment.isVisible());
        }
      }

  
      public RequestManager get(@NonNull Activity activity) {
        if (Util.isOnBackgroundThread()) {
            //非主线程按全局context处理
          return get(activity.getApplicationContext());
        } else {
          assertNotDestroyed(activity);
            //重点，获取ftagment的管理者FragmentManager对象
          android.app.FragmentManager fm = activity.getFragmentManager();
          return fragmentGet(
              activity, fm, /*parentHint=*/ null, isActivityVisible(activity));
        }
      }


      public RequestManager get(@NonNull View view) {
        if (Util.isOnBackgroundThread()) {
            //非主线程按全局context处理
          return get(view.getContext().getApplicationContext());
        }

        Preconditions.checkNotNull(view);
        Preconditions.checkNotNull(view.getContext(),
            "Unable to obtain a request manager for a view without a Context");
        Activity activity = findActivity(view.getContext());
        if (activity == null) {
          return get(view.getContext().getApplicationContext());
        }

   
        if (activity instanceof FragmentActivity) {
          Fragment fragment = findSupportFragment(view, (FragmentActivity) activity);
          return fragment != null ? get(fragment) : get(activity);
        }

        
        android.app.Fragment fragment = findFragment(view, activity);
          //通过不同的重载方法get获取RequestManager对象
        if (fragment == null) {
          return get(activity);
        }
        return get(fragment);
      }
    
    
     private RequestManager fragmentGet( Context context,
   			android.app.FragmentManager fm,
     		android.app.Fragment parentHint,
      		boolean isParentVisible) {
         //获取一个RequestManagerFragment，它就是一个Fragment
  		 RequestManagerFragment current = getRequestManagerFragment(fm, parentHint, 																		isParentVisible);
         //获取RequestManagerFragment的RequestManager对象
   		 RequestManager requestManager = current.getRequestManager();
   		 if (requestManager == null) {
      	 //创建RequestManager对象
         Glide glide = Glide.get(context);
         requestManager = factory.build(
              glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), 				  context);
         //RequestManager对象和RequestManagerFragment绑定，通过Fragment的生命周期，影响		     																		RequestManager
         current.setRequestManager(requestManager);
         }
         return requestManager;
  }
    
    //和上面一样，只不过这是v4包的。
     private RequestManager supportFragmentGet(
         Context context,
         FragmentManager fm,
         Fragment parentHint,
         boolean isParentVisible) {
        SupportRequestManagerFragment current =
            getSupportRequestManagerFragment(fm, parentHint, isParentVisible);
        RequestManager requestManager = current.getRequestManager();
        if (requestManager == null) {
              Glide glide = Glide.get(context);
              requestManager =
                  factory.build( glide, current.getGlideLifecycle(), 						                              current.getRequestManagerTreeNode(), context);
              current.setRequestManager(requestManager);
        }
        return requestManager;
  }
    
    //获取RequestManagerFragment对象
     private RequestManagerFragment getRequestManagerFragment(
      @NonNull final android.app.FragmentManager fm,
      @Nullable android.app.Fragment parentHint,
      boolean isParentVisible) {
     //从FragmentManager中获取Fragment对象
    RequestManagerFragment current = (RequestManagerFragment) fm.findFragmentByTag(FRAGMENT_TAG);
    if (current == null) {
        //pendingRequestManagerFragments是一个hashMap对象
      current = pendingRequestManagerFragments.get(fm);
      if (current == null) {
          //创建RequestManagerFragment对象
        current = new RequestManagerFragment();
        current.setParentFragmentHint(parentHint);
        if (isParentVisible) {
          current.getGlideLifecycle().onStart();
        }
          //将上面创建的RequestManagerFragment对象存入pendingRequestManagerFragments的hashMap对象中
        pendingRequestManagerFragments.put(fm, current);
          //add到当前activity中，这样它的生命周期就可以和当前activity同步了
        fm.beginTransaction().add(current, FRAGMENT_TAG).commitAllowingStateLoss();
          //通过消息机制，删除pendingRequestManagerFragments的fm键值对。之所以删除，是因为已经不需要了，上面put是因为防止多次调用这个方法，造成创建多个RequestManagerFra。gment对象。
        handler.obtainMessage(ID_REMOVE_FRAGMENT_MANAGER, fm).sendToTarget();
      }
    }
    return current;
  }
}
```

ok,with方法讲完了，总结一下，with方法返回一个`RequestManager`对象。内部会添加一个隐藏的fragment对象，通过这个对象，使`RequestManager`和`activity`的生命周期同步。

```java
public class RequestManager implements LifecycleListener,
    ModelTypes<RequestBuilder<Drawable>> {
    。。。。。。
    }
```

可以看到，`RequestManager`继承`LifecycleListener`对象。

```java
public interface LifecycleListener {
  void onStart();
  void onStop();
  void onDestroy();
}
```

`Activity`生命周期变化时，就会回调相应的方法。

### load()

```java
public RequestBuilder<Drawable> load(@Nullable String string) {
    return asDrawable().load(string);
  }
```

从这个方法可以看出，返回的是`RequestBuilder`，显然`Glide`对于各种请求用到了`Builder设计模式`。

下面来分析`adDrawable方法`

```java
public RequestBuilder<Drawable> asDrawable() {
    return as(Drawable.class);
  }

public <ResourceType> RequestBuilder<ResourceType> as(
    @NonNull Class<ResourceType> resourceClass) {
    return new RequestBuilder<>(glide, this, resourceClass, context);
}
```

在`adDrawable`方法中，继续调用`as`方法，传入`Drawable.classs`参数，接着创建`RequestBuilder`对象。`RequestBuilder`中涉及到大量的图片加载参数的设置。接着我们看`RequestBuilder#load`传入的第一个参数。

```java
public class RequestBuilder<TranscodeType> extends BaseRequestOptions<RequestBuilder<TranscodeType>>
    implements Cloneable,
    ModelTypes<RequestBuilder<TranscodeType>> {
        
        .......
            
    public RequestBuilder<TranscodeType> load(@Nullable String string) {
        return loadGeneric(string);
     }
        
    private RequestBuilder<TranscodeType> loadGeneric(@Nullable Object model) {
        this.model = model;
        isModelSet = true;
        return this;
    }
}
```

这个方法就是设置model属性的值。接下来我们来看最重要的`into()`方法。

### into()

上面都是小打小闹，现在才正式开始，`into()`是整个`Glide`加载流程最复杂的地方。

```java
public ViewTarget<ImageView, TranscodeType> into(@NonNull ImageView view) {
    Util.assertMainThread();
    Preconditions.checkNotNull(view);

    BaseRequestOptions<?> requestOptions = this;
    if (!requestOptions.isTransformationSet()
        && requestOptions.isTransformationAllowed()
        && view.getScaleType() != null) {
      switch (view.getScaleType()) {
        case CENTER_CROP:
          requestOptions = requestOptions.clone().optionalCenterCrop();
          break;
        case CENTER_INSIDE:
          requestOptions = requestOptions.clone().optionalCenterInside();
          break;
        case FIT_CENTER:
        case FIT_START:
        case FIT_END:
          requestOptions = requestOptions.clone().optionalFitCenter();
          break;
        case FIT_XY:
          requestOptions = requestOptions.clone().optionalCenterInside();
          break;
        case CENTER:
        case MATRIX:
        default:
          // Do nothing.
      }
    }

    return into(
        glideContext.buildImageViewTarget(view, transcodeClass),//
        /*targetListener=*/ null,
        requestOptions,
        Executors.mainThreadExecutor());
  }
```

上面一堆判断逻辑就是图片变换，就是在原图展示之前，有进行了一些变换处理，从而能实现丰富的图片效果，比如圆角化、圆形化、模糊化等等。当然，这上面都是默认的，你可以自定义。网上也有很多图片变换开源库，其中最出色的就是`glide-transformations`，`glide-transformations`的项目主页地址是 https://github.com/wasabeef/glide-transformations

我们主要关注最后一句话,调用三个参数的`into`方法，第一参数是一个`Tager`对象，`Tager`对象是最终用来展示图片的。第二个参数是null，不管。第三个参数是`BaseRequestOptions`对象，顾名思义，就是用来展示图片所需要的参数。第四个参数是回调执行器，就是利用handler机制回到主线程中。

我们主要关注第一个参数，`glideContext.buildImageViewTarget(view, transcodeClass)`，第一个参数是我们让设置图片的`ImageView`,第二个参数在本例是`Drawable.class`。

```java
 @NonNull
  public <X> ViewTarget<ImageView, X> buildImageViewTarget(
      @NonNull ImageView imageView, @NonNull Class<X> transcodeClass) {
    return imageViewTargetFactory.buildTarget(imageView, transcodeClass);
  }
```

这个方法调用`ImageViewTargetFactory`的`buildTarget`方法。

```java
public class ImageViewTargetFactory {
    
  public <Z> ViewTarget<ImageView, Z> buildTarget(@NonNull ImageView view,
      @NonNull Class<Z> clazz) {
    if (Bitmap.class.equals(clazz)) {
      return (ViewTarget<ImageView, Z>) new BitmapImageViewTarget(view);
    } else if (Drawable.class.isAssignableFrom(clazz)) {
      return (ViewTarget<ImageView, Z>) new DrawableImageViewTarget(view);
    } else {
      throw new IllegalArgumentException(
          "Unhandled class: " + clazz + ", try .as*		(Class).transcode(ResourceTranscoder)");
    }
  }
}
```

可以看到，我们最终会得到`DrawableImageViewTarget`,这个`target`非常重要。接着我们继续分析`into`方法

```java
private <Y extends Target<TranscodeType>> Y into(
      @NonNull Y target,
      @Nullable RequestListener<TranscodeType> targetListener,
      BaseRequestOptions<?> options,
      Executor callbackExecutor) {
    Preconditions.checkNotNull(target);
    if (!isModelSet) {
      throw new IllegalArgumentException("You must call #load() before calling #into()");
    }

    //核心1 这里传入了BaseRequestOptions和Traget对象，说明我们的图片参数都是设置到这个Request对象，并且通过Request，将图片传到Traget对象里，然后Traget对象设置到ImageView。
    Request request = buildRequest(target, targetListener, options, callbackExecutor);

    //从DrawableImageViewTarget对象获取正在执行的Request。
    Request previous = target.getRequest();
    //判断是否复用，我们这里previous为空，这个条件不通过
    if (request.isEquivalentTo(previous)
        && !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) {
      if (!Preconditions.checkNotNull(previous).isRunning()) {
        previous.begin();
      }
      return target;
    }

    requestManager.clear(target);
    target.setRequest(request);
    //核心2 开始执行Request
    requestManager.track(target, request);

    return target;
  }
```

这里我们只看核心代码，核心1通过`buildRequest`创建了一个`Request`对象，核心2通过`requestManager`的`track`来执行这个`Request`。

#### Request创建

```java
private Request buildRequest(
      Target<TranscodeType> target,
      @Nullable RequestListener<TranscodeType> targetListener,
      BaseRequestOptions<?> requestOptions,
      Executor callbackExecutor) {
    //这里提取了requestOptions的一些信息以及transitionOptions的信息
    return buildRequestRecursive(
        target,
        targetListener,
        transitionOptions,
        requestOptions.getPriority(),
        requestOptions.getOverrideWidth(),
        requestOptions.getOverrideHeight(),
        requestOptions,
        callbackExecutor);
  }


private Request buildRequestRecursive(
      Target<TranscodeType> target,
      @Nullable RequestListener<TranscodeType> targetListener,
      @Nullable RequestCoordinator parentCoordinator,
      TransitionOptions<?, ? super TranscodeType> transitionOptions,
      Priority priority,
      int overrideWidth,
      int overrideHeight,
      BaseRequestOptions<?> requestOptions,
      Executor callbackExecutor) {
    
    ......

   //这里创建mainRequest对象
    Request mainRequest =
        buildThumbnailRequestRecursive(
            target,
            targetListener,
            parentCoordinator,
            transitionOptions,
            priority,
            overrideWidth,
            overrideHeight,
            requestOptions,
            callbackExecutor);

    if (errorRequestCoordinator == null) {
      return mainRequest;
    }
  }


 private Request buildThumbnailRequestRecursive(
      Target<TranscodeType> target,
      RequestListener<TranscodeType> targetListener,
      @Nullable RequestCoordinator parentCoordinator,
      TransitionOptions<?, ? super TranscodeType> transitionOptions,
      Priority priority,
      int overrideWidth,
      int overrideHeight,
      BaseRequestOptions<?> requestOptions,
      Executor callbackExecutor) {
     
     //这里主要跟缩略图有关，我们并没有设置
    if (thumbnailBuilder != null) {
    
      if (isThumbnailBuilt) {
          
       .......
           
      return coordinator;
    } else if (thumbSizeMultiplier != null) {
     
       .......
          
      return coordinator;
    } else {
          //创建Request对象
      return obtainRequest(
          target,
          targetListener,
          requestOptions,
          parentCoordinator,
          transitionOptions,
          priority,
          overrideWidth,
          overrideHeight,
          callbackExecutor);
    }
  }

  private Request obtainRequest(
      Target<TranscodeType> target,
      RequestListener<TranscodeType> targetListener,
      BaseRequestOptions<?> requestOptions,
      RequestCoordinator requestCoordinator,
      TransitionOptions<?, ? super TranscodeType> transitionOptions,
      Priority priority,
      int overrideWidth,
      int overrideHeight,
      Executor callbackExecutor) {
      //创建SingleRequest.
    return SingleRequest.obtain(
        context,
        glideContext,
        model,
        transcodeClass,
        requestOptions,
        overrideWidth,
        overrideHeight,
        priority,
        target,
        targetListener,
        requestListeners,
        requestCoordinator,
        glideContext.getEngine(),
        transitionOptions.getTransitionFactory(),
        callbackExecutor);
  }

```

`SingleRequest`是Request的子类，通过`target`，`BaseRequestOptions`等参数创建。这里通过`SingleRequest.obtain`创建，用到了享元的设计模式，出于对内存的节省。



#### Request执行

`Request`创建结束后，就要开始执行了,我们继续分析上面的核心2.

```java
//核心2
requestManager.track(target, request);
```

```java
public class RequestManager implements LifecycleListener,
    ModelTypes<RequestBuilder<Drawable>> {
        
        。。。。。。
            
    synchronized void track(@NonNull Target<?> target, @NonNull Request request) {
        targetTracker.track(target);
         //执行Request
        requestTracker.runRequest(request);
      }
 
        。。。。。。
  }

```

这里的`TargetTracker`和`RequestTracker`对象分别保存了所有的target和request对象。我们发现`TargetTracker`，`RequestManager`均实现了`LifecycleListener`接口，`RequestTracker`虽然未实现，但内部也有几个相应的感知生命周期的方法。 

我们看下

```java
RequestManager(
      Glide glide,
      Lifecycle lifecycle,
      RequestManagerTreeNode treeNode,
      RequestTracker requestTracker,
      ConnectivityMonitorFactory factory,
      Context context) {
    connectivityMonitor =
        factory.build(
            context.getApplicationContext(),
            new RequestManagerConnectivityListener(requestTracker));

    if (Util.isOnBackgroundThread()) {
    
    } else {
        //重点
      lifecycle.addListener(this);
    }
    //重点
    lifecycle.addListener(connectivityMonitor);
}

```

每个`Activity`都绑定了一个`RequestManager`,所有生命周期的变化都会通过`RequestManager`进行分发，然后传通知`TargetTracker`和`RequestTracker`等相关类。这样，各个部分都能通过`Lifecycle`进行相关操作，比如`request`的取消和启动。这样我们知道了`LifecycleListener`和`LifeCircle`的作用，也没啥神秘的。

我们接着分析`request#runRequest`

```java
public void runRequest(@NonNull Request request) {
    requests.add(request);
    //是否是OnPause状态
    if (!isPaused) {
        //启动Request
      request.begin();
    } else {
      request.clear();
      if (Log.isLoggable(TAG, Log.VERBOSE)) {
        Log.v(TAG, "Paused, delaying request");
      }
        //加入ArrayList对象pendingRequests中。
      pendingRequests.add(request);
    }
  }
```

这里`pendingRequests`作用就是保证不被GC，因为`requests`是`WeakHashMap`弱引用。

下面来分析begin()

```java
public synchronized void begin() {
    assertNotCallingCallbacks();
    stateVerifier.throwIfRecycled();
    startTime = LogTime.getLogTime();
    if (model == null) {
      if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
        width = overrideWidth;
        height = overrideHeight;
      }
     
      int logLevel = getFallbackDrawable() == null ? Log.WARN : Log.DEBUG;
      onLoadFailed(new GlideException("Received null model"), logLevel);
      return;
    }

    if (status == Status.RUNNING) {
      throw new IllegalArgumentException("Cannot restart a running request");
    }
    if (status == Status.COMPLETE) {
      onResourceReady(resource, DataSource.MEMORY_CACHE);
      return;
    }

    status = Status.WAITING_FOR_SIZE;
    if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
      onSizeReady(overrideWidth, overrideHeight);
    } else {
      target.getSize(this);
    }

    if ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)
        && canNotifyStatusChanged()) {
      target.onLoadStarted(getPlaceholderDrawable());
    }
    if (IS_VERBOSE_LOGGABLE) {
      logV("finished run method in " + LogTime.getElapsedMillis(startTime));
    }
  }
```

这里首先对model进行判断，model就是我们传递的`url`,如果model为空，就会调用`onLoadFailed`方法，此方法会调用一些回调方法和`setErrorPlaceholder`方法，如下所示：

```java
 private synchronized void setErrorPlaceholder() {
    if (!canNotifyStatusChanged()) {
      return;
    }

    Drawable error = null;
    if (model == null) {
      error = getFallbackDrawable();
    }
    // Either the model isn't null, or there was no fallback drawable set.
    if (error == null) {
      error = getErrorDrawable();
    }
    // The model isn't null, no fallback drawable was set or no error drawable was set.
    if (error == null) {
      error = getPlaceholderDrawable();
    }
    target.onLoadFailed(error);
  }

```

此方法会调用`target.onLoadFailed(error)`给`ImageView`设置错误占位图.

```java
public abstract class ImageViewTarget<Z> extends ViewTarget<ImageView, Z>
    implements Transition.ViewAdapter {
    
    。。。。。
        
    public void onLoadFailed(@Nullable Drawable errorDrawable) {
        super.onLoadFailed(errorDrawable);
        setResourceInternal(null);
        setDrawable(errorDrawable);
      }
      
     public void setDrawable(Drawable drawable) {
    	view.setImageDrawable(drawable);
     }
  
 }
```

这里的`target`是`DrawableImageViewTarget`，它的父类就是`ImageViewTarget`，可以看到，最终会调用`ImageView`的`setImageDrawable`方法。

回到`SingleRequest#begin()`

接着，会判断是否设置宽高，如果设置了就会调用`onSizeReady`，否则，就会设置一个回调，最后也会触发`onSizeReady`方法。

那么我们就来分析这个方法

```java
public synchronized void onSizeReady(int width, int height) {
    stateVerifier.throwIfRecycled();
    if (IS_VERBOSE_LOGGABLE) {
      logV("Got onSizeReady in " + LogTime.getElapsedMillis(startTime));
    }
    if (status != Status.WAITING_FOR_SIZE) {
      return;
    }
    status = Status.RUNNING;

    float sizeMultiplier = requestOptions.getSizeMultiplier();
    this.width = maybeApplySizeMultiplier(width, sizeMultiplier);
    this.height = maybeApplySizeMultiplier(height, sizeMultiplier);

    if (IS_VERBOSE_LOGGABLE) {
      logV("finished setup for calling load in " + LogTime.getElapsedMillis(startTime));
    }
    loadStatus =
        engine.load(
            glideContext,
            model,
            requestOptions.getSignature(),
            this.width,
            this.height,
            requestOptions.getResourceClass(),
            transcodeClass,
            priority,
            requestOptions.getDiskCacheStrategy(),
            requestOptions.getTransformations(),
            requestOptions.isTransformationRequired(),
            requestOptions.isScaleOnlyOrNoTransform(),
            requestOptions.getOptions(),
            requestOptions.isMemoryCacheable(),
            requestOptions.getUseUnlimitedSourceGeneratorsPool(),
            requestOptions.getUseAnimationPool(),
            requestOptions.getOnlyRetrieveFromCache(),
            this,
            callbackExecutor);
    if (status != Status.RUNNING) {
      loadStatus = null;
    }
    if (IS_VERBOSE_LOGGABLE) {
      logV("finished onSizeReady in " + LogTime.getElapsedMillis(startTime));
    }
  }
```

这里会先检查status是否是等待size的状态，如果不是，说明size已经设置好了，会将status设置成`Status.RUNNING`状态，然后调用`engine#load`方法,这个方法我们随后在分析。这里load倒数第二个参数会设置一个回调`ResourceCallback`。

```java
public interface ResourceCallback {
  void onResourceReady(Resource<?> resource, DataSource dataSource);

  void onLoadFailed(GlideException e);
}
```

`ResourceCallback#onResourceReady`最终会告诉`target`结果，`traget`就会通知view展示最终结果。

回到`SingleRequest#begin()`,最后会调用`target.onLoadStarted(getPlaceholderDrawable())`

```java
public void onLoadStarted(@Nullable Drawable placeholder) {
    super.onLoadStarted(placeholder);
    setResourceInternal(null);
    setDrawable(placeholder);
  }
```

这里就是提前设置view的一些状态，比如`placeholder`信息等等，然后等待`engine#load`加载完。

##### engine#load

```java
public class Engine implements EngineJobListener,
    MemoryCache.ResourceRemovedListener,
    EngineResource.ResourceListener {
    
    。。。。。。
    
    public synchronized <R> LoadStatus load(
      GlideContext glideContext,
      Object model,
      Key signature,
      int width,
      int height,
      Class<?> resourceClass,
      Class<R> transcodeClass,
      Priority priority,
      DiskCacheStrategy diskCacheStrategy,
      Map<Class<?>, Transformation<?>> transformations,
      boolean isTransformationRequired,
      boolean isScaleOnlyOrNoTransform,
      Options options,
      boolean isMemoryCacheable,
      boolean useUnlimitedSourceExecutorPool,
      boolean useAnimationPool,
      boolean onlyRetrieveFromCache,
      ResourceCallback cb,
      Executor callbackExecutor) {
    long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;

     //1 构建缓存key.
    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
        resourceClass, transcodeClass, options);
	
    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
    if (active != null) {
      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
      }
      return null;
    }

    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
    if (cached != null) {
      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Loaded resource from cache", startTime, key);
      }
      return null;
    }

    EngineJob<?> current = jobs.get(key, onlyRetrieveFromCache);
    if (current != null) {
      current.addCallback(cb, callbackExecutor);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Added to existing load", startTime, key);
      }
      return new LoadStatus(cb, current);
    }

    EngineJob<R> engineJob =
        engineJobFactory.build(
            key,
            isMemoryCacheable,
            useUnlimitedSourceExecutorPool,
            useAnimationPool,
            onlyRetrieveFromCache);

    DecodeJob<R> decodeJob =
        decodeJobFactory.build(
            glideContext,
            model,
            key,
            signature,
            width,
            height,
            resourceClass,
            transcodeClass,
            priority,
            diskCacheStrategy,
            transformations,
            isTransformationRequired,
            isScaleOnlyOrNoTransform,
            onlyRetrieveFromCache,
            options,
            engineJob);

    jobs.put(key, engineJob);

    engineJob.addCallback(cb, callbackExecutor);
    engineJob.start(decodeJob);

    if (VERBOSE_IS_LOGGABLE) {
      logWithTimeAndKey("Started new load", startTime, key);
    }
    return new LoadStatus(cb, engineJob);
  }
  
}
```

load()方法大多数跟缓存有关，关于缓存后面在讲，现在主要是把整个加载流程跑通。这里主要创建了两个类`EngineJob`和`DecodeJob`。前者主要是开启线程和通过回调通知`Request`。后者主要是对图片进行解码,但它的任务很繁重。

##### DecondeJob

`DecodeJob`实现了`Runnable`接口，懂得一些套路的朋友就知道了，它的入口就是run方法。

```java
public void run() {
    GlideTrace.beginSectionFormat("DecodeJob#run(model=%s)", model);
    DataFetcher<?> localFetcher = currentFetcher;
    try {
        //检查是否取消
      if (isCancelled) {
          //通知上层调用失败
        notifyFailed();
        return;
      }
        //真正请求的地方
      runWrapped();
    } catch (CallbackException e) {
      if (Log.isLoggable(TAG, Log.DEBUG)) {
        Log.d(TAG, "DecodeJob threw unexpectedly"
            + ", isCancelled: " + isCancelled
            + ", stage: " + stage, t);
      }
      if (stage != Stage.ENCODE) {
        throwables.add(t);
        notifyFailed();
      }
      if (!isCancelled) {
        throw t;
      }
      throw t;
    } finally {
      if (localFetcher != null) {
          //清理资源
        localFetcher.cleanup();
      }
      GlideTrace.endSection();
    }
  }
```

这里首先检查`isCancelled`标志位，他是一个volatile变量，支持多线程可见性，由此保证`DecodeJob`可以被安全取消。之后调用`runWrapped()`执行正真的请求，这个函数稍后分析。最后调用`localFetcher.cleanup();`清理资源，`localFetcher`是负责具体请求数据的地方，请求完后，要关闭文件，数据流等一些操作。

接着分析`DecodeJon#runWapped`

```java

 private void runWrapped() {
    switch (runReason) {
      case INITIALIZE:
        stage = getNextStage(Stage.INITIALIZE);
        currentGenerator = getNextGenerator();
        runGenerators();
        break;
      case SWITCH_TO_SOURCE_SERVICE:
        runGenerators();
        break;
      case DECODE_DATA:
        decodeFromRetrievedData();
        break;
      default:
        throw new IllegalStateException("Unrecognized run reason: " + runReason);
    }
  }

 private Stage getNextStage(Stage current) {
    switch (current) {
      case INITIALIZE:
        return diskCacheStrategy.decodeCachedResource()
            ? Stage.RESOURCE_CACHE : getNextStage(Stage.RESOURCE_CACHE);
      case RESOURCE_CACHE:
        return diskCacheStrategy.decodeCachedData()
            ? Stage.DATA_CACHE : getNextStage(Stage.DATA_CACHE);
      case DATA_CACHE:
        return onlyRetrieveFromCache ? Stage.FINISHED : Stage.SOURCE;
      case SOURCE:
      case FINISHED:
        return Stage.FINISHED;
      default:
        throw new IllegalArgumentException("Unrecognized stage: " + current);
    }
  }


```

这里`runReason`默认是`INITIALIZE`,通过`getNextStage(Stage.INITIALIZE)`获取Stage状态。`diskCacheStrategy.decodeCachedResource()`默认为true,因此这里的Stage状态为` Stage.RESOURCE_CACHE`.接下来，通过`getNextGenerator()`获取一个`DataFetcherGenerator`对象。

```java
  private DataFetcherGenerator getNextGenerator() {
    switch (stage) {
      case RESOURCE_CACHE:
        return new ResourceCacheGenerator(decodeHelper, this);
      case DATA_CACHE:
        return new DataCacheGenerator(decodeHelper, this);
      case SOURCE:
        return new SourceGenerator(decodeHelper, this);
      case FINISHED:
        return null;
      default:
        throw new IllegalStateException("Unrecognized stage: " + stage);
    }
  }
```

这个方法就是根据stage状态，获取不同的`DataFetcherGenerator`对象。这里stage是`Stage.RESOURCE_CACHE`，因此返回`ResourceCacheGenerator`。

继续分许`DecodeJob#runWrapped()`，接着调用`DecodeJob#runGenerators()`

```java
private void runGenerators() {
    currentThread = Thread.currentThread();
    startFetchTime = LogTime.getLogTime();
    boolean isStarted = false;
    while (!isCancelled && currentGenerator != null
        && !(isStarted = currentGenerator.startNext())) {
      stage = getNextStage(stage);
      currentGenerator = getNextGenerator();

      if (stage == Stage.SOURCE) {
        reschedule();
        return;
      }
    }
    // We've run out of stages and generators, give up.
    if ((stage == Stage.FINISHED || isCancelled) && !isStarted) {
      notifyFailed();
    }

    // Otherwise a generator started a new load and we expect to be called back in
    // onDataFetcherReady.
  }
```

在这个while循环中，会先检查`isCancelled`，如果为true或`isStarted`为true,表示任务已经启动成功，就会结束整个循环。接着，会判断stage完成或任务取消并且任务没有启动，那么就会`notifyFailed`。下面继续分析while循环，考虑任务没有被取消，`DataFetcherGenerator#startNext`返回值表示任务是否启动成功。

第一次循环，`currentGenerator`为`ResourceCacheGenerator`，假设没有启动成功，再次进入`getNextStage`，stage为`Stage.RESOURCE_CACHE`，所以返回下一个状态`DATA_CACHE`,接着`getNextGenerator`,根据stage返回`DataCacheGenerator`。

第二次循环，`currentGenerator`为`DataCacheGenerator`,假设没有启动成功，再次进入`getNextStage`，stage为`Stage.DATA_CACHE`，`onlyRetrieveFromCache`为false,所以返回下一个状态`SOURCE`,接着`getNextGenerator`,根据stage返回`SourceGenerator`。内部循环return，`runReason`被置为`RunReason.SWITCH_TO_SOURCE_SERVICE`，重新执行`DecodeJob`.

```java
 public void reschedule() {
    runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;
    callback.reschedule(this);
  }
```

继续执行`DecodeJob`的`run`方法，接着又进入`runWrapped`。`runReason`为`RunReason.SWITCH_TO_SOURCE_SERVICE`，`stage`为`Stage.SOURCE`，此时`currentGenerator`为`SourceGenerator`，接着又进入while循环，假设任务没有启动成功，此时进入while循环内，`getNextStage`返回`Stage.FINISHED`，`currentGenerator`为空。循环结束，并`notifyFailed`。

我们得到结论，**`DecodeJob#run`会依次执行`ResourceCacheGenerator`->`DataCacheGenerator`->`SourceGenerator`,当其中一个返回`startNext()`返回true时，就不会在执行下一个`DataFetcherGenerator`**

我们根据上述结论，在来看while循环。

`ResourceCacheGenerator`和`DataCacheGenerator`都是从缓存文件取数据，因为我们没有缓存文件，所以它们的`startNext`返回false,我们直接看`SourceGenerator#startNext`

```java
public boolean startNext() {
    if (dataToCache != null) {
      Object data = dataToCache;
      dataToCache = null;
      //缓存数据
      cacheData(data);
    }build

    if (sourceCacheGenerator != null && sourceCacheGenerator.startNext()) {
      return true;
    }
    sourceCacheGenerator = null;

    loadData = null;
    boolean started = false;
    while (!started && hasNextModelLoader()) {
      loadData = helper.getLoadData().get(loadDataListIndex++);
      if (loadData != null
          && (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())
          || helper.hasLoadPath(loadData.fetcher.getDataClass()))) {
        started = true;
        loadData.fetcher.loadData(helper.getPriority(), this);
      }
    }
    return started;
  }
```

这个方法主要分两部分，第一部分是缓存文件，第二部分是请求数据。初次进入方法是，`dataToCache`为空，跳过缓存数据。直接看while循环的内容,我们重点看` loadData = helper.getLoadData().get(loadDataListIndex++)`这句代码

```java
final class DecodeHelper<Transcode> {
    List<LoadData<?>> getLoadData() {
        if (!isLoadDataSet) {
          isLoadDataSet = true;
          loadData.clear();
          List<ModelLoader<Object, ?>> modelLoaders = glideContext.getRegistry().getModelLoaders(model);
          //noinspection ForLoopReplaceableByForEach to improve perf
          for (int i = 0, size = modelLoaders.size(); i < size; i++) {
            ModelLoader<Object, ?> modelLoader = modelLoaders.get(i);
            LoadData<?> current =
                modelLoader.buildLoadData(model, width, height, options);
            if (current != null) {
              loadData.add(current);
            }
          }
        }
        return loadData;
      }
  }
```

这个方法就是获取`List<ModelLoader>`，然后调用每个`ModelLoader`的`buildLoadData`方法，获取对应的`LoadData`，并存到`list`中。我们继续看`Registry#getModelLoaders`方法如何获取`ModelLoader`,这个方法传入的参数就是String类型的`url`.

```java
 public <Model> List<ModelLoader<Model, ?>> getModelLoaders(@NonNull Model model) {
    List<ModelLoader<Model, ?>> result = modelLoaderRegistry.getModelLoaders(model);
    if (result.isEmpty()) {
      throw new NoModelLoaderAvailableException(model);
    }
    return result;
  }

```

这个方法调用`ModelLoaderRegistry#getModelLoaders`

```java
public <A> List<ModelLoader<A, ?>> getModelLoaders(@NonNull A model) {
    List<ModelLoader<A, ?>> modelLoaders = getModelLoadersForClass(getClass(model));
    int size = modelLoaders.size();
    boolean isEmpty = true;
    List<ModelLoader<A, ?>> filteredLoaders = Collections.emptyList();
    //noinspection ForLoopReplaceableByForEach to improve perf
    for (int i = 0; i < size; i++) {
      ModelLoader<A, ?> loader = modelLoaders.get(i);
      if (loader.handles(model)) {
        if (isEmpty) {
          filteredLoaders = new ArrayList<>(size - i);
          isEmpty = false;
        }
        filteredLoaders.add(loader);
      }
    }
    return filteredLoaders;
  }

```

这个方法就是调用每个`ModelLoader`的handles方法，来筛选符合我们`model`的`ModelLoader`。然后再添加到`filteredLoaders`这个list中返回。我们继续看`ModelLoaderRegistry#getModelLoadersForClass`方法

```java
@NonNull
  private synchronized <A> List<ModelLoader<A, ?>> getModelLoadersForClass(
      @NonNull Class<A> modelClass) {
    List<ModelLoader<A, ?>> loaders = cache.get(modelClass);
    if (loaders == null) {
      loaders = Collections.unmodifiableList(multiModelLoaderFactory.build(modelClass));
      cache.put(modelClass, loaders);
    }
    return loaders;
  }
```

这里参数是`String.class`，最终调用`multiModelLoaderFactory.build(modelClass)`来获取`ModelLoader`。

继续往下看`MultiModelLoaderFactory#build`

```java
 synchronized <Model> List<ModelLoader<Model, ?>> build(@NonNull Class<Model> modelClass) {
    try {
      List<ModelLoader<Model, ?>> loaders = new ArrayList<>();
      for (Entry<?, ?> entry : entries) {
        if (alreadyUsedEntries.contains(entry)) {
          continue;
        }
        if (entry.handles(modelClass)) {
          alreadyUsedEntries.add(entry);
          loaders.add(this.<Model, Object>build(entry));
          alreadyUsedEntries.remove(entry);
        }
      }
      return loaders;
    } catch (Throwable t) {
      alreadyUsedEntries.clear();
      throw t;
    }
  }

 private <Model, Data> ModelLoader<Model, Data> build(@NonNull Entry<?, ?> entry) {
    return (ModelLoader<Model, Data>) 
        Preconditions.checkNotNull(entry.factory.build(this));
  }
```

原来最终就是遍历`entries`，调用`entry.factory.build(this)`来得到`ModelLoader`。那这个`entries`怎么来的呢？

```java
Glide(
      @NonNull Context context,
      @NonNull Engine engine,
      @NonNull MemoryCache memoryCache,
      @NonNull BitmapPool bitmapPool,
      @NonNull ArrayPool arrayPool,
      @NonNull RequestManagerRetriever requestManagerRetriever,
      @NonNull ConnectivityMonitorFactory connectivityMonitorFactory,
      int logLevel,
      @NonNull RequestOptions defaultRequestOptions,
      @NonNull Map<Class<?>, TransitionOptions<?, ?>> defaultTransitionOptions,
      @NonNull List<RequestListener<Object>> defaultRequestListeners,
      boolean isLoggingRequestOriginsEnabled) {
   
    registry = new Registry();

    registry
        .append(String.class, InputStream.class, new DataUrlLoader.StreamFactory<String>())
        .append(String.class, InputStream.class, new StringLoader.StreamFactory())
        .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
        .append(
            String.class, AssetFileDescriptor.class, new StringLoader.AssetFileDescriptorFactory())
        .append(Uri.class, InputStream.class, new HttpUriLoader.Factory())
        .append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())
       

  }
```

原来在最开始创建`Glide`通过`registry.append`注册进去的，这里省略了大量无关代码。

```java
append(String.class, InputStream.class, new DataUrlLoader.StreamFactory<String>())
        .append(String.class, InputStream.class, new StringLoader.StreamFactory())
        .append(String.class, ParcelFileDescriptor.class, new StringLoader.FileDescriptorFactory())
        .append(
            String.class, AssetFileDescriptor.class, new StringLoader.AssetFileDescriptorFactory())
```

最终会往`MultiModelLoaderFactory`的`entries`变量添加如上四条数据。Entry结构如下

```java
  private static class Entry<Model, Data> {
    private final Class<Model> modelClass;
    @Synthetic final Class<Data> dataClass;
    @Synthetic final ModelLoaderFactory<? extends Model, ? extends Data> factory;
    }
```

由此可知，将会调用每个`append`的`ModelLoaderFactory`的build方法来构建`ModelLoader`。然后调用每个`c`的`handles`方法进行筛选。最后调用每个筛选后的``ModelLoader`对象的`fetcher`对象的`loadData`方法记载数据。

我们来看看`append(String.class, InputStream.class, new StringLoader.StreamFactory())`这条Entry的`ModelLoaderFactory#build`方法

```java
public static class StreamFactory implements ModelLoaderFactory<String, InputStream> {

    @NonNull
    @Override
    public ModelLoader<String, InputStream> build(
        @NonNull MultiModelLoaderFactory multiFactory) {
      return new StringLoader<>(multiFactory.build(Uri.class, InputStream.class));
    }

  }
```

这个方法又调用`multiFactory.build(Uri.class, InputStream.class)`来获取另一个`ModelLoader`。

最终会得到这条Entry，`append(GlideUrl.class, InputStream.class, new HttpGlideUrlLoader.Factory())`

回到`SourceGenerator#startNext`，根据上面结论

这个方法会调用`HttpGlideUrlLoader.fetcher.loadData(helper.getPriority(), this)`来加载数据

```java
public class HttpUrlFetcher implements DataFetcher<InputStream> {
    
    public void loadData(@NonNull Priority priority,
          @NonNull DataCallback<? super InputStream> callback) {
        long startTime = LogTime.getLogTime();
        try {
            //通过url获取图片的数据流
          InputStream result = loadDataWithRedirects(glideUrl.toURL(), 0, null, glideUrl.getHeaders());
          callback.onDataReady(result);
        } catch (IOException e) {
          if (Log.isLoggable(TAG, Log.DEBUG)) {
            Log.d(TAG, "Failed to load data for url", e);
          }
          callback.onLoadFailed(e);
        } finally {
          if (Log.isLoggable(TAG, Log.VERBOSE)) {
            Log.v(TAG, "Finished http url fetcher fetch in " + LogTime.getElapsedMillis(startTime));
          }
        }
      }
    
    //主要是HttpURLconnection网络请求
    private InputStream loadDataWithRedirects(URL url, int redirects, URL lastUrl,
      Map<String, String> headers) throws IOException {
    if (redirects >= MAXIMUM_REDIRECTS) {
      throw new HttpException("Too many (> " + MAXIMUM_REDIRECTS + ") redirects!");
    } else {
      // Comparing the URLs using .equals performs additional network I/O and is generally broken.
      // See http://michaelscharf.blogspot.com/2006/11/javaneturlequals-and-hashcode-make.html.
      try {
        if (lastUrl != null && url.toURI().equals(lastUrl.toURI())) {
          throw new HttpException("In re-direct loop");

        }
      } catch (URISyntaxException e) {
        // Do nothing, this is best effort.
      }
    }

    urlConnection = connectionFactory.build(url);
    for (Map.Entry<String, String> headerEntry : headers.entrySet()) {
      urlConnection.addRequestProperty(headerEntry.getKey(), headerEntry.getValue());
    }
    urlConnection.setConnectTimeout(timeout);
    urlConnection.setReadTimeout(timeout);
    urlConnection.setUseCaches(false);
    urlConnection.setDoInput(true);
    urlConnection.setInstanceFollowRedirects(false);
    urlConnection.connect();
    stream = urlConnection.getInputStream();
    if (isCancelled) {
      return null;
    }
    final int statusCode = urlConnection.getResponseCode();
    if (isHttpOk(statusCode)) {
      return getStreamForSuccessfulRequest(urlConnection);
    } else if (isHttpRedirect(statusCode)) {
      String redirectUrlString = urlConnection.getHeaderField("Location");
      if (TextUtils.isEmpty(redirectUrlString)) {
        throw new HttpException("Received empty or null redirect url");
      }
      URL redirectUrl = new URL(url, redirectUrlString);
      cleanup();
      return loadDataWithRedirects(redirectUrl, redirects + 1, url, headers);
    } else if (statusCode == INVALID_STATUS_CODE) {
      throw new HttpException(statusCode);
    } else {
      throw new HttpException(urlConnection.getResponseMessage(), statusCode);
    }
  }
      
 }
```

这里就是通过`HttpURLconnection`网络来获取图片数据流，获取数据成功后回调执行`SourceGenerator#onDataReady`方法接受数据流，继续回调`DecodeJob#onDataFetcherReady`将数据流封装成`Resource`，继续回调`EngineJob#onResourceReady`将线程转换为主线程，继续回调`Engine#onEngineJobComplete`缓存图片和回调`SingleRequest$onResourceReady`调用`target#onResourceReady`设置`ImageView`。

Glide网络加载图片分析完毕，我们继续来分析缓存加载

##### 缓存加载图片

Glide缓存机制考虑的场景非常全面，在缓存上，Glide分为内存和硬盘缓存。接下来我们重新从`Engine#load`分析缓存文件。

```java
public class Engine implements EngineJobListener,
    MemoryCache.ResourceRemovedListener,
    EngineResource.ResourceListener {
    
    。。。。。。
    
    public synchronized <R> LoadStatus load(
      GlideContext glideContext,
      Object model,
      Key signature,
      int width,
      int height,
      Class<?> resourceClass,
      Class<R> transcodeClass,
      Priority priority,
      DiskCacheStrategy diskCacheStrategy,
      Map<Class<?>, Transformation<?>> transformations,
      boolean isTransformationRequired,
      boolean isScaleOnlyOrNoTransform,
      Options options,
      boolean isMemoryCacheable,
      boolean useUnlimitedSourceExecutorPool,
      boolean useAnimationPool,
      boolean onlyRetrieveFromCache,
      ResourceCallback cb,
      Executor callbackExecutor) {
    long startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : 0;

     //1 构建缓存key.
    EngineKey key = keyFactory.buildKey(model, signature, width, height, transformations,
        resourceClass, transcodeClass, options);
	//2
    EngineResource<?> active = loadFromActiveResources(key, isMemoryCacheable);
    if (active != null) {
      cb.onResourceReady(active, DataSource.MEMORY_CACHE);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Loaded resource from active resources", startTime, key);
      }
      return null;
    }
	//3
    EngineResource<?> cached = loadFromCache(key, isMemoryCacheable);
    if (cached != null) {
      cb.onResourceReady(cached, DataSource.MEMORY_CACHE);
      if (VERBOSE_IS_LOGGABLE) {
        logWithTimeAndKey("Loaded resource from cache", startTime, key);
      }
      return null;
    }

  
}
```

###### 缓存key

要缓存必须得有key,Glide的key生成参数有很多。这段代码通过`keyFactory`构建一个`EngineKey`,`EngineKey`主要是重写了`equals()`和`hashCode()`方法,保证了所有参数相同的情况下才是同一个Key，具体源码，同学感兴趣可以自己研究.

###### 内存缓存

注释2会调用`loadFromActiveResources`获取缓存,获取就会回调`onResourceReady`方法。如果没获取到，就会调用注释3处的`loadFromCache`方法获取，获取成功同样会回调。这两个方法一个是弱引用，另一个是`LruCache`算法。直接来看源码：

```java
private EngineResource<?> loadFromActiveResources(Key key, boolean isMemoryCacheable) {
    if (!isMemoryCacheable) {
      return null;
    }
    EngineResource<?> active = activeResources.get(key);
    if (active != null) {
      active.acquire();
    }

    return active;
  }

private EngineResource<?> loadFromCache(Key key, boolean isMemoryCacheable) {
    if (!isMemoryCacheable) {
      return null;
    }

    EngineResource<?> cached = getEngineResourceFromCache(key);
    if (cached != null) {
      cached.acquire();
      activeResources.activate(key, cached);
    }
    return cached;
  }

private EngineResource<?> getEngineResourceFromCache(Key key) {
    Resource<?> cached = cache.remove(key);

    final EngineResource<?> result;
    if (cached == null) {
      result = null;
    } else if (cached instanceof EngineResource) {
      result = (EngineResource<?>) cached;
    } else {
      result = new EngineResource<>(cached, true , true );
    }
    return result;
  }
```

`loadFromActiveResources`方法首先判断`isMemoryCacheable`,这个为false表示内存缓存被禁用。然后直接从弱引用中获取数据。

`loadFromCache`首先从cache中获取缓存，这个cache就是在创建Glide对象时传入的`LruResourceCache`，那说明这个就是LRU算法了。接着，会将缓存图片从cache移除掉，然后添加`activeResources`弱引用中，用来缓存图片，这样可以保证这些使用的图片不会被LRU算法回收掉。

既然知道了内存缓存的读取原理，那么在哪里写入的呢

通过前面分析，数据加载成功后，会回调`Engine#onEngineJobComplete`方法。

```java
public synchronized void onEngineJobComplete(
      EngineJob<?> engineJob, Key key, EngineResource<?> resource) {
    // A null resource indicates that the load failed, usually due to an exception.
    if (resource != null) {
      resource.setResourceListener(key, this);

      if (resource.isCacheable()) {
        activeResources.activate(key, resource);
      }
    }

    jobs.removeIfCurrent(key, engineJob);
  }
```

这个方法会将`EngineResource`put到`activeResources`中。

但这只是弱引用缓存，另一种`LruCache`在哪里写入了。这里就跟`EngineResource`有关了，这类有两个方法`acquire()`和`release()`

```java
synchronized void acquire() {
    if (isRecycled) {
      throw new IllegalStateException("Cannot acquire a recycled resource");
    }
    ++acquired;
  }

  void release() {
    synchronized (listener) {
      synchronized (this) {
        if (acquired <= 0) {
          throw new IllegalStateException("Cannot release a recycled or not yet acquired resource");
        }
        if (--acquired == 0) {
          listener.onResourceReleased(key, this);
        }
      }
    }
  }

```

当`acquired`变量大于0时，说明图片正在使用，应该放到`activeResources`弱引用缓存中。当

`release()`后，`acquired`变量等于0,就会调用`listener`的`onResourceReleased`方法释放资源，这个`listener`就是`Engine`。

```java
 public synchronized void onResourceReleased(Key cacheKey, EngineResource<?> resource) {
    activeResources.deactivate(cacheKey);
    if (resource.isCacheable()) {
      cache.put(cacheKey, resource);
    } else {
      resourceRecycler.recycle(resource);
    }
  }

```

可以看到，这里首先会将图片缓存从`activeResources`移除，然后put到`cache`中。这样就实现了正在使用的用弱引用缓存，不在使用的用LRU缓存。



###### 硬盘缓存

