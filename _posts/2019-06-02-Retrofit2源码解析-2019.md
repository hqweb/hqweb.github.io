---
layout:     post   				    
title:      Retrofit2源码解析				 
subtitle:   Retrofit2源码解析
date:       2019-06-02 				
author:     hq 						
header-img: img/post-bg-2015.jpg 	
catalog: true 						
tags:								
    - 源码
---



# Retrofit2源码解析

Android开发中，Retrofit是最常用的网络请求库，它的底层是基于okhttp3,相较于ohkttp3,帮我们避免了很多重复的写法，同时灵活性也非常高，可以自定义okhttpclient,Converter,CallAdapter。



## 1.  基本用例

来自[retrofit官网][https://square.github.io/retrofit/]

版本2.4.0

```groovy
implementation 'com.squareup.retrofit2:retrofit:2.4.0'
```

### 1.1 创建 retrofit 对象

```java
Retrofit retrofit = new Retrofit.Builder()
    .baseUrl("url")
    .addConverterFactory(GsonConverterFactory.create())
    .build();
```

用到了Builder模式

### 1.2 定义 API 并获取 API 实例

```java
public interface RemoteService {
  @GET("/request")
  Call<DataBean> getData(@Path("par") String user);
}

RemoteService myService = retrofit.create(RemoteService.class);
```

用到了外观模式（门面模式），`retrofit.create()`就是门面。很多优秀的开源库都有门面，比如`Glide.with()` `ImageLoader.load()` 等。

### 1.3  生成call对象，并请求网络

```java
Call<DataBean> call = myService.getData();
call.enqueue(new Callback<DataBean>() {
    @Override
    public void onResponse(Call<DataBean> call, Response<DataBean> response) {
        
    }

    @Override
    public void onFailure(Call<DataBean> call, Throwable t) {
        
    }
});
```



## 2.源码分析

### 2.1 Retrofit的创建

```java
public Retrofit build() {
    //这里可以看出我们必需设置baseUrl
    if (baseUrl == null) {
        throw new IllegalStateException("Base URL required.");
    }
    
    //如果我们没有设置自定义的OkHttpClient，就用默认的OkHttpClient
    okhttp3.Call.Factory callFactory = this.callFactory;
    if (callFactory == null) {
        callFactory = new OkHttpClient();
    }
    
    //这个callbackExecutor用于回调到UI线程
    Executor callbackExecutor = this.callbackExecutor;
    if (callbackExecutor == null) {
        callbackExecutor = platform.defaultCallbackExecutor();
    }

    //将我们设置的Call适配器添加到列表中，比如RxJava的适配器
    List<CallAdapter.Factory> callAdapterFactories = new ArrayList<>(this.callAdapterFactories);
    //添加默认的Call适配器
    callAdapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));

    // Make a defensive copy of the converters.
    List<Converter.Factory> converterFactories =
            new ArrayList<>(1 + this.converterFactories.size());

    //添加数据转换器，用于将网络请求返回的结果转换成我们需要的类型
    converterFactories.add(new BuiltInConverters());
    converterFactories.addAll(this.converterFactories);
    
    //构建Retrofit
    return new Retrofit(callFactory, baseUrl, unmodifiableList(converterFactories),
            unmodifiableList(callAdapterFactories), callbackExecutor, validateEagerly);
}

```

通过上面build的方法，总结如下：

- 用于执行网络请求的callFactory，默认是okHttpClient.

- callbackExecutor回调执行器，这个是用于网路请求返回主线程的。

  可以看到，这么跟platform有关

  ```java
  //Retrofit.class
  public Builder() {
      this(Platform.get());
  }
  
  Builder(Platform platform) {
      this.platform = platform;
  }
  
  ```

  在Builder方法中，获取paltform,然后在build方法中，通过platform的defaultCallbackExecutor方法获取回调执行器。下面我们来看platform方法

  ```java
  class Platform {
      private static final Platform PLATFORM = findPlatform();
  
      static Platform get() {
          return PLATFORM;
      }
  
      private static Platform findPlatform() {
          try {
              Class.forName("android.os.Build");
              if (Build.VERSION.SDK_INT != 0) {
                  return new Android();
              }
          } catch (ClassNotFoundException ignored) {
          }
          try {
              Class.forName("java.util.Optional");
              return new Java8();
          } catch (ClassNotFoundException ignored) {
          }
          return new Platform();
      }
      
      ...
      
      static class Android extends Platform {
          @Override
          public Executor defaultCallbackExecutor() {
              return new MainThreadExecutor();
          }
  
          @Override
          CallAdapter.Factory defaultCallAdapterFactory(@Nullable Executor callbackExecutor) {
              if (callbackExecutor == null) throw new AssertionError();
              return new ExecutorCallAdapterFactory(callbackExecutor);
          }
  
          static class MainThreadExecutor implements Executor {
              private final Handler handler = new Handler(Looper.getMainLooper());
  
              @Override
              public void execute(Runnable r) {
                  handler.post(r);
              }
          }
      }
  }
  
  ```

  从上面源码可以看出，platform会根据当前不同的平台返回不同的子类。这里返回的是Android子类，所以就是利用handler回到主线程中

- callAdapterFactories是call适配器列表，这里面存放的就是callAdapter。Retrofit底层采用的okhttp，所以采用的call接口来请求并处理失败成功的结果。但我们可能需要结合其他第三方库，比如rxjava，就要将call是配成observable。这就是callAdapter的作用

  ​	

  ```java
  @GET("/")
  Observable<DataBean> getObservableData();
  ```

- converterFactories是结果转换器列表。call返回的Response类型，它可以帮我们转换成DataBean实体类新。如GsonConverterFactory就是常用的转换器。

  

### 2.2 总结

- 从retrofit的创建过程我们可以看出它其中的核心成分包括OKHttpClient,CallAdapter适配器,converter转换器

  以及callbackExecutor回调执行器

- Retrofit采用Builder模式，外观模式，做了很大的封装，但灵活扩展性依然很高。



